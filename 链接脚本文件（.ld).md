# 链接脚本文件（.ld)



## **基础与前置知识 (Why & What)**

### **编译链接全景图**

#### 回顾 C/C++ 程序的生命周期：预处理 -> 编译 -> 汇编 -> **链接**。

![img](figures/v2-437fd9d7112a81cd32b6325aec131606_r.jpg)

**1. 预处理 (Preprocessing)**

处理源代码中以 `#` 开头的“预处理指令”。可能包含的动作有：宏展开、头文件包含、条件编译、注释清除。其最后的输出仍然是C代码，但通常经过“净化”或者“膨胀”的 `.i` 文件。

**2. 编译 (Compilation)**

将预处理后的C代码翻译成特定于目标机器的汇编代码。可能包含的动作有：词法分析、语法分析、语义分析、优化、生成汇编代码。输出为汇编代码 `.s`文件。但现阶段编译器是独立处理每个文件的，只是把高级语言翻译成更接近机器的低级语言（汇编）。

**3. 汇编 (Assembly)**

将汇编代码转换为机器可以执行的二进制指令。可能包含的动作有： 将汇编代码转换为机器可以执行的二进制指令、将这些机器码，连同代码和数据，打包成特定格式的文件**(可重定位目标文件 Relocatable Object File)** 。输出为目标文件 `.o` 文件。该 `.o` 文件包含：

- 编译单元（单个 `.c` 文件）的机器码和数据
- 符号表，记录了工程定义了哪些函数和变量，包括内部外部的
- 由于地址是相对的、未决的，还不知道main函数的最终确切地址，因此是被称为“可重定位的“。

**4. 链接 (Linking)**

这是整个流程的“总装”阶段，也是链接脚本发挥作用的地方。将多个目标文件和库文件组成一个单一的可执行文件。包含的输入文件有所有的目标文件 `*.o` ，可能需要的c标准库文件。其可能包含的动作有：

- 符号解析：链接器扫描所有的输入目标文件、构建一个全局的符号表，检查每个文件引用的外部符号是否有对应定义（如无则报错）；
- 重定位：将所有输入文件中的同名段合并，把各种 `.o` 文件的 `.text`段合并成最终可执行文件的一个大 `.text`段；合并后会分配运行时的内存地址，最终输出一个完整的、可以直接加载到内存运行的可执行文件。



如果不提供自定义的链接脚本，链接器会使用一个默认的、适合通用操作系统的脚本。但在嵌入式开发、操作系统内核等需要精细内存控制的场景下，你就必须亲手编写这份“图纸”，来确保程序能正确地在特定的硬件上运行。



**理解链接器的核心任务1 - 符号解析（Symbol Resolution）**

为一个做工程创建一个**符号表**，里面会记录每个文件定义的全局符号、每个文件所引用的外部符号、每个文件的内部定义符号。类似于 SourceInsight中的符号表



**理解链接器的核心任务2 - 重定位（Relocation）**

找到了所有符号的定义后，将它们安排在最终的内存地址中。目标文件会有一个**重定位表 (Relocation Table)** ，记录下“当链接完成时，请回来把占位符地址修正一下“。

1. **分配地址 (Assign Addresses)：** 链接器根据链接脚本（或默认规则）为合并后的段分配运行时的虚拟内存地址。比如，它决定 `.text` 段从 `0x401000` 开始，`.data` 段从 `0x602000` 开始。这样，每个函数和全局变量都有了最终的、绝对的内存地址。例如，`main` 函数的地址是 `0x401100`，`print_message` 函数的地址是 `0x401120`。
2. **修正引用 (Update References)：** 最后，链接器会遍历重定位表，将代码中所有占位符地址替换为上一步计算出的真实地址。它会找到 `main` 函数中那条 `call` 指令，并将其操作数从 `0x00000000` 修改为 `print_message` 的实际地址 `0x401120`。

重定位就是链接器在“填空”，把所有代码和数据放到最终位置，并更新所有内部的地址引用，使程序能够正确执行。



### 区分静态链接与动态链接

#### 静态链接

在编译链接阶段，将所有需要的库代码的副本直接复制到最终的可执行文件中。例如在代码中使用库函数 `printf`时，链接器会从静态库文件(`.a` 或 `.lib`文件) 中取出包含该函数及所依赖的其他函数模块，然后将这些取出的模块进行上述的符号解析和重定位，合并成一个完全独立、自给自足的可执行文件。

**优点**

- 可移植性好：因为所有依赖都打包进去了，所以可执行文件可以拷贝到任何兼容的系统上运行，无需担心目标系统上是否存在所需的库。

- 运行速度可能更快：所有代码都在一个文件内，理论上加载速度更快，函数调用也可能是最快的，因为地址在编译时就已确定。

**缺点**

- 体积巨大：如果 100 个程序都静态链接了 `libc`，那么内存和磁盘上就会有 100 份 `libc` 的副本，造成巨大浪费。
- **更新困难**：如果库本身有一个安全漏洞需要修复（比如 `libc` 更新了），需要重新编译链接所有依赖它的程序，才能应用这个修复。



#### 动态链接

在程序运行时，才将程序与所需的共享库代码结合起来。在编译链接阶段，链接器只会做一些“预备工作”。当它看到 `printf` 被调用时时，不会复制 `printf` 的代码，而是在可执行文件中记录一个标记：“需要一个名为 `printf` 的函数，它位于共享库 `libc.so` 中”。

当在命令行运行这个程序时，操作系统的**动态链接器/加载器 (Dynamic Linker/Loader)** 会介入，检查程序需要哪些共享库（如 `libc.so`），在内存中查找这个库（如果其他程序已经加载了它，就直接共享；如果没有，就加载一份到内存），然后，它像一个“运行时链接器”，完成**最后一步重定位**，将程序中对 `printf` 的调用指向内存中 `libc.so` 的 `printf` 函数的实际地址。

**优点**

- **节省空间**：多个程序可以共享内存中同一份库的副本，极大地节省了磁盘和内存空间。
- **易于维护**：如果库更新了（例如修复了安全漏洞），只需替换系统中的那个 `.so` 文件即可。所有依赖该库的程序在下次运行时，都会自动加载新版本的库，无需重新编译。

**缺点**

- 体积巨大：如果 100 个程序都静态链接了 `libc`，那么内存和磁盘上就会有 100 份 `libc` 的副本，造成巨大浪费。
- 更新困难：如果库本身有一个安全漏洞需要修复（比如 `libc` 更新了），需要重新编译链接所有依赖它的程序，才能应用这个修复。

| 特性               | 静态链接               | 动态链接               |
| :----------------- | :--------------------- | :--------------------- |
| **链接时间**       | 编译时完成             | 主要在运行时完成       |
| **可执行文件大小** | 大                     | 小                     |
| **内存占用**       | 高（每个程序一份副本） | 低（多程序共享一份）   |
| **可移植性**       | 强（自给自足）         | 弱（依赖外部环境）     |
| **更新维护**       | 困难（需重新编译）     | 简单（替换库文件即可） |

在现代桌面和服务器操作系统中，**动态链接是默认和主流的方式**。而在嵌入式系统或需要创建完全独立的发行包时，**静态链接**仍然非常有用。



#### **核心概念入门**

- **目标文件 (Object File, .o)** ：了解其基本结构，特别是 ELF (Executable and Linkable Format) 格式。

  在Object文件中，每一个section有一个名字还有对应的size信息，几乎所有的section都有一个数据关联块（associated block of data）。

- **段 (Section)** ：深入理解 `.text`, `.data`, `.rodata`, `.bss` 等标准段的含义和作用。这是链接脚本操作的基本单位。

  大多数时候，我们会把输入的Object文件里面的section称之为 input section。链接输出的单个Object文件里面的section称之为output section。

- **符号 (Symbol)** ：理解函数名、变量名等如何成为符号表中的条目。

- **内存布局 (Memory Layout)** ：理解程序在内存中的基本分区（代码区、数据区、堆、栈）。



## 链接脚本核心语法 (The Core)

链接脚本由一系列语句组成，一种是命令语句，另一种是赋值语句。与C的相似之处：

- 用 `;` 作为分隔符
- 表达式与运算符
- 注释的字符的引用



### **脚本基本结构与入口命令**

这些命令通常放在脚本的开头，用于定义整个输出文件的全局属性。

- `ENTRY(symbol)`：指定程序的入口点（例如 `_start`）。
- `OUTPUT_FORMAT(format)`：定义输出文件的格式（如 `elf64-x86-64`）。
- `OUTPUT_ARCH(architecture)`：指定输出文件的目标架构。



#### ENTRY(symbol)

在标准的C程序中，入口点通常由C运行时库（CRT）处理，最终调用 main 函数。但在没有操作系统的裸机（Bare-metal）环境中，必须明确告诉链接器程序的“第一站”入口是哪里。这个入口点通常是一个用汇编语言编写的启动函数，如 `_start` 或 `Reset_Handler`。

指定了程序的入口点。当操作系统或引导加载程序（Bootloader）运行程序时，会跳转到这里指定的 `symbol` (通常是一个函数名) 开始执行第一条指令。

示例：

```
ENTRY(Reset_Handler)
```

 `_start` 标签通常在汇编启动文件（如 `startup.s`）中定义

#### OUTPUT_FORMAT

通常有两种，`format` 和 `architecture`

对于 `format `定义输出文件的二进制格式。最常见的格式是 ELF (Executable and Linkable Format)。

格式：通常包含三部分 `elf<bitness>-<architecture>-<endianness>`。

对于`architecture` 指定输出文件的目标CPU架构

示例：

```
OUTPUT_ARCH(i386:x86-64)
OUTPUT_ARCH(arm)

ENTRY(Reset_Handler)

OUTPUT_FORMAT(elf32-littlearm)
OUTPUT_FORMAT(elf64-x86-64)
```

 

### MEMORY命令 - 定义内存

这是链接脚本在嵌入式开发中至关重要的第一步。它用来向链接器描述目标硬件的物理内存分布情况。定义一个或多个内存区域，并给它们命名，指定它们的起始地址、大小和属性。链接器会用这些信息来检查后续的布局安排是否合法（例如，有没有把太多的东西放进一个太小的内存里）。

标准结构及示例：

```c
/*  标准结构  */
MEMORY
{
  name1 (attr1) : ORIGIN = start_address1, LENGTH = size1
  name2 (attr2) : ORIGIN = start_address2, LENGTH = size2
  /* ... more regions ... */
}

/*  实际示例  */
/*  假设一个微控制器有 128KB 的 Flash（起始于 0x08000000）和 20KB 的 RAM（起始于 0x20000000）  */
MEMORY
{
  FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 128K
  RAM   (rwx): ORIGIN = 0x20000000, LENGTH = 20K
}
```

- `name`: 为内存区域起的名字，如 `FLASH`, `RAM`；

- `attr`: 区域的属性，是 `r` (只读), `w` (可读写), `x` (可执行), `a` (可分配)的组合；

  - `FLASH` 通常是 `(rx)`：可读、可执行，但不可写。

  - `RAM` 通常是 `(rwx)`：可读、可写、可执行。

- `ORIGIN`: 内存区域的起始物理地址。
- `LENGTH`: 内存区域的大小，支持 `K` (kilobytes) 和 `M` (megabytes) 后缀。



### SECTIONS命令 - ld核心内容

链接脚本的主要命令之一是 **SECTIONS**，这是链接脚本**最核心、最复杂**的部分。它详细描述了如何将输入文件（`.o` 文件）中的各个段（sections）组合成输出文件中的段，并将它们放置到 `MEMORY` 命令定义的内存区域中。其基本语法结构：

```c
SECTIONS
{
  /* 输出段定义 */
  output_section_name :
  {
    /* 输入段描述 */
    input_section_descriptions
  } > memory_region

  /* 更多输出段定义 */
}

SECTIONS {
  .text : { *(.text) }  /* 将所有输入文件的 .text section 合并到输出文件的 .text section */
  .data : { *(.data) }  /* 类似处理 .data */
}

/* “*” 表示所有输入文件，“(.text)” 表示匹配的输入 section。 */
```



#### 段 (Section)

在目标文件（object file，如 .o 文件）和可执行文件（如 ELF - 链接脚本用于控制链接器如何将对象文件中的section组合成可执行文件格式的文件）中，程序的代码和数据被分成多个独立的逻辑单元，这些单元就叫作 **section**。每个section都有一个名字，并包含特定的类型内容：

- **.text**：存放可执行代码（指令）;
- **.data**：存放已初始化的全局变量和静态变量;
- **.bss**：存放未初始化的全局变量和静态变量（在运行时会清零）;
- **.rodata**：存放只读数据，如字符串常量、 const 变量；
- .**srodata:** 包含只读的小数据段（某些架构的优化）；
- **.startup**：专门用来存放最关键的启动代码，特别是复位向量（Reset Vector）
- 其他如 .init（初始化代码）、.fini（终止代码）等。



#### 输出**段**的定义

```c
output_section_name  [address] [(type)] : [AT(lma)] { contents } >region [=fill]
```

- **output_section_name** 

  你为最终输出文件中的这个段起的名字，如 `.text`, `.data`

- **[address]**

  直接指定该输出段的运行时地址 (VMA - Virtual Memory Address) 。这会覆盖链接器基于 MEMORY 区域和前一个段的位置自动计算的地址。通常不推荐手动指定，除非有非常特殊的需求。

- **[(type)]** (可选)

  指定段的类型。最常用的是 `(NOLOAD)`，它告诉链接器为这个段分配空间和地址，但不要在最终的可执行文件中包含它的内容。这正是 `.bss` 段所需要的，因为它只是一块需要在运行时清零的内存区域，没必要在文件中存储一堆零来浪费空间。

  示例: `.bss (NOLOAD) : { ... } > RAM`

- **>region** (强烈推荐)

  将该输出段放置到 `MEMORY` 中定义的某个内存区域。这会决定该段的 **VMA**。链接器会自动将该段放置在 `region` 中可用的最低地址上。

- **AT(lma)** (关键高级特性)

  lma 指的是加载地址 (LMA - Load Memory Address) 。

- **[=fill]** (可选)

  用一个指定的值来填充段内由于对齐等原因产生的空隙。例如 `=0xFF`。



#### 输出段的内容 {contents}

**基本通配符 `*`**

- `*(.text)`：包含**所有**输入文件（`.o`）的 `.text` 段。这是最常见的用法。
- `*(.text .text.* .gnu.linkonce.t.*)`：包含所有名为 `.text`、所有以 `.text.` 开头、以及所有以 `.gnu.linkonce.t.` 开头的段。这种写法更健壮，可以捕获编译器因优化（如内联函数）而生成的各种变体段。

**指定特定文件**

- `startup.o(.text)`：只包含 `startup.o` 文件中的 `.text` 段。
- 通常希望启动代码、中断向量表等放在最前面，就可以用这种方式精确控制顺序。
- **示例**：`KEEP(startup.o(.isr_vector))`

**COMMON 符号**

- 在 C 语言中，未初始化的全局变量（如 `int global_var;`）在旧的编译模型中会被放入一个叫做 `COMMON` 的特殊空间。
- 链接器在处理时，会将所有 `COMMON` 符号收集起来，为它们在 `.bss` 段中分配空间。所以在 `.bss` 的定义中常能看到 `*(COMMON)`。

**排除文件 `EXCLUDE_FILE`**

- `*(EXCLUDE_FILE (*_special.o) .text)`：包含所有文件的 `.text` 段，除了那些以 `_special.o` 结尾的文件。



#### 内容中的常见用法技巧

**1. 位置计数器 `.` (The Location Counter)**

- 它始终代表**输出段内的当前地址**。
- 对齐：`. = ALIGN(4);` 是最常见的用法，确保接下来的内容从4字节对齐的地址开始。处理器访问对齐的地址效率更高，有些甚至强制要求。

```
.my_section :
{
    _my_section_start = . ;   /* 定义一个符号，记录该段的起始地址 */
    *(.some_data)
    *(.another_data)
    _my_section_end = . ;     /* 定义一个符号，记录该段的结束地址 */
}
/* 在段外，你可以计算该段的大小 */
_my_section_size = _my_section_end - _my_section_start;

/* 另一种写法，等同于 SIZEOF(.my_section) */
_my_section_size = SIZEOF(.my_section);
```

* 常见的其他一些函数
  - `ALIGN(align_bytes)`：将位置计数器对齐到指定字节。
  - `SIZEOF(section_name)`：获取某个输出段的大小。
  - `ADDR(section_name)`：获取某个输出段的地址。


**2. KEEP() 命令**

- 链接器有一项优化叫“垃圾回收”（Garbage Collection），如果它发现某个函数或变量从未被代码引用，就会将其丢弃以减小文件大小。
- 但有些代码（如中断服务程序 `ISR`）虽然没有被主代码直接调用，却由硬件触发，是必需的。
- `KEEP(*(.isr_vector))` 强制链接器保留中断向量表，即使它看起来“未被使用”。
- `KEEP(*(.reset_vector))` 这行代码强制链接器保留 `.reset_vector` 段，即使它看起来像是“未使用”的。这可以防止垃圾回收机制错误地删除了程序的启动点。
- 复位向量：当MCU上电或复位时，CPU硬件被设计为自动从一个固定的内存地址去取第一条指令。这个固定的地址就叫做复位向量地址。

**3. 特殊输出段 /DISCARD/**

- 这是一个“黑洞”，任何被放入这个段的输入段都会被丢弃，不会出现在最终的输出文件中。
- 常用于丢弃调试信息、注释等，以生成一个纯净的、最小体积的发布版本。
- 示例: `/DISCARD/ : { *(.comment) *(.debug_info) }`

**4. PROVIDE 命令的妙用**

`PROVIDE` 用于定义一个符号，但它是一个弱定义。意思是：只有当这个符号没有在任何被链接的输入文件中被定义时，`PROVIDE` 定义才会生效。如果输入文件已经定义了同名符号，则链接器会使用输入文件中的定义。

例如 `PROVIDE(__global_pointer$ = . + 0x800);`：

- 这行代码在RISC-V架构中，`__global_pointer$` (或 `gp`) 是全局指针寄存器，用于高效地访问全局变量。
- 它尝试将全局指针的默认值设置在当前位置 (`.`) 偏移 `0x800` 字节处。这通常是在 `.sdata`（小数据区）的中间位置。
- 如果启动代码或C库中已经精确地计算并定义了 `__global_pointer$`，那么 `PROVIDE` 的定义就会被忽略。这提供了一种灵活的默认配置方式。

**5. ASSERT：添加编译时检查**

你可以使用 `ASSERT` 命令在链接时进行断言检查。如果断言条件为假，链接过程会失败并打印一条错误信息。这对于防止内存溢出等错误非常有用。例如：

```
SECTIONS
{
    /* ... */
    .text : { *(.text) } > rom
    .data : { *(.data) } > ram AT> rom

    /* 检查 .text 和 .data 的总大小是否超过了 ROM 的容量 */
    /* 注意：SIZEOF(.data) 算的是 VMA 大小，但它同样占据 LMA 空间 */
    ASSERT(SIZEOF(.text) + SIZEOF(.data) <= LENGTH(rom), "ROM is full!")

    /* 检查 .data 和 .bss 的总大小是否超过了 RAM 的容量 */
    ASSERT(SIZEOF(.data) + SIZEOF(.bss) < LENGTH(ram), "RAM is full!")
}
```







#### **VMA vs. LMA 精解**

- **VMA (运行时地址)** ：程序**运行时**，这个段应该在的地址。CPU 执行代码、读写数据时看到的是 VMA。`>region` 主要设定的是 VMA。
- **LMA (加载时地址)** ：这个段的内容被**存储**在可执行文件中的哪个地址或者说应该从哪个地址加载。
- **在多数情况下，VMA 和 LMA 是相同的**。例如，`.text` 段，它既被存储在 FLASH 中，也在 FLASH 中运行。
- 关键应用场景：初始化的数据 (`.data`)
  - `.data` 段包含已初始化的全局变量（如 `int g_value = 10;`）。
  - 这个值 `10` 必须随可执行文件一起被**存储**在非易失性存储器（FLASH）中。所以它的 **LMA 在 FLASH 里**。
  - 但是，变量在运行时是需要被修改的，所以它必须被加载到可读写的 RAM 中去运行。所以它的 **VMA 在 RAM 里**。
- `AT(lma)` 就是用来显式声明：“这个段的 VMA 在 RAM 里（由 `>RAM` 决定），但请把它打包存储在 FLASH 的某个位置（由 `AT()` 决定）”。



## 案例分析 (Practice & Case Studies)

### 实例1

```c
/* ... MEMORY 定义部分 ... */
MEMORY
{
  FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 128K
  RAM   (rwx): ORIGIN = 0x20000000, LENGTH = 20K
}

/* 提供C代码可以使用的堆栈顶部地址 */
_estack = ORIGIN(RAM) + LENGTH(RAM);

SECTIONS
{
    /* ========= 代码和只读数据段，位于 FLASH ========= */
    .text :
    {
        . = ALIGN(4);
        _stext = .;          /* 符号：标记.text段的开始 */
        KEEP(*(.isr_vector)) /* 1. 强制保留中断向量表，并放在最前面 */
        
        *(.text)             /* 2. 放置所有文件的代码 */
        *(.text.*)
        
        *(.rodata)           /* 3. 放置所有只读数据 */
        *(.rodata.*)
        
        . = ALIGN(4);
        _etext = .;          /* 符号：标记.text段的结束 */
        
    } > FLASH /* VMA 和 LMA 都在 FLASH */

    /* ========= 已初始化数据段，VMA在RAM，LMA在FLASH ========= */
    /* 你的启动代码需要将这个段从 _sidata (LMA) 拷贝到 _sdata (VMA) */
    .data :
    {
        . = ALIGN(4);
        _sdata = .;          /* 符号：标记.data段在RAM中的开始地址 (VMA) */
        
        *(.data)
        *(.data.*)
        
        . = ALIGN(4);
        _edata = .;          /* 符号：标记.data段在RAM中的结束地址 (VMA) */

    } > RAM AT > FLASH       /* VMA在RAM，但将其加载(存储)在FLASH中.text段之后 */

    _sidata = LOADADDR(.data); /* 符号：创建.data段的加载地址(LMA)的符号 */

    /* ========= 未初始化数据段，仅在RAM中占据空间 ========= */
    .bss (NOLOAD) :
    {
        . = ALIGN(4);
        _sbss = .;           /* 符号：标记.bss段的开始 */
        
        *(.bss)
        *(.bss.*)
        *(COMMON)
        
        . = ALIGN(4);
        _ebss = .;           /* 符号：标记.bss段的结束 */
    } > RAM

    /* 检查是否超出了FLASH或RAM的大小 */
    ._user_heap_stack (NOLOAD) :
    {
      . = ALIGN(8);
      . = . + _MIN_HEAP_SIZE; /* 可选：为堆预留空间 */
      . = . + _MIN_STACK_SIZE;/* 可选：为栈预留空间 */
      . = ALAIN(8);
    } > RAM
}
```



### 实例2

```c
/* 
* Copyright (c) 2025, WISEWAVE Corporation.
* All rights reserved.
*/ 


ENTRY(_start)

__rom_size = 64K;  /* 其值为 64 * 1024 字节  */
__dlm_size = 88K;  /*  DLM 通常指数据本地内存（Data Local Memory），一种高速的RAM */
__stack_size = 8K;  /* 用于后续分配栈空间的大小 */

/*  声明目标硬件的内存区域、属性、起始地址和大小  */
MEMORY
{
  rom (rx) : ORIGIN = 0x40000000, LENGTH = __rom_size /* BOOTROM: 可读、可执行 */
  ram (rw) : ORIGIN = 0x00200000, LENGTH = __dlm_size /* DLM（SRAM）：可读、可写 */
}

SECTIONS
{
    /* Reset vector must be at start of BOOTROM */ 
    .startup : {
        KEEP(*(.reset_vector))
    } > rom

    /* Executable code and R0 data into BOOTROM */
    .text : {
        *(.text .text.*)
        *(.rodata .rodata* .rodata.*)
        *(.srodata .srodata* .srodata.*)
    } > rom

    .data : ALIGN(8) {
        ...
        provide(__global_pointer$ = . + 0x800;);
        ...
    } > ram AT> rom /*  指定了 .data 段的 加载地址 (LMA) 。这意味着该段的初始值被存储在 rom 中（紧跟在 .text 段之后）。启动代码需要将这部分数据从ROM拷贝到RAM */
        

    __data_lmastart = LOADADDR(.data); /* 其值为 .data 段在 ROM 中的加载地址 (LMA)  */
    __data_start = ADDR(.data);
    __data_end = ADDR(.data) + SIZEOF(.data);
    __data_size = SIZEOF(.data);

    .bss (NOLOAD) : {
        *(.sbss .sbss* .sbss.*)
        *(.bss .bss* .bss.*)
        *(COMMON)
    } > ram

    __bss_start = ADDR(.bss);
    __bss_end = ADDR(.bss) + SIZEOF(.bss);
    __bss_size = SIZEOF(.bss);

    /* Stack is allocated after all data. */
    /* Stack grows from high to low addresses */
    /* 定义栈的最低地址（栈底）。它位于 .bss 段结束之后，并进行了16字节对齐（某些处理器架构推荐或要求栈对齐）  */
    __stack_min = ALIGN(__bss_end, 16); 
    /* 栈是从高地址向低地址生长的, 计算出的是栈的起始地址（栈顶)，程序的栈指针（SP）寄存器在启动时会被初始化为 __stack 的值。当函数调用发生压栈操作时，SP的值会减小。 */
    __stack = __stack_min + __stack_size;
}
```

- `_start` 是一个符号（Symbol） ，通常在汇编语言写的启动文件（比如 `startup.s`）中定义。这个启动文件负责进行最底层的硬件初始化，比如设置时钟、初始化内存控制器、准备C语言运行环境等；
- `ENTRY(_start)` 是给最终生成的可执行文件（如 ELF 文件）打上一个标记：在加载器运行程序的时候从 `_start` 这个地址开始”；
- `*(.text .text.*)`：第一个 `*` 是一个通配符，表示所有输入的目标文件（`*.o`），
- **`KEEP(\*(.reset_vector))`** : 将所有输入文件 (`*`) 中的 `.reset_vector` 段放在这里。`KEEP` 指令强制链接器保留这个段，防止它因为“未被引用”而被优化掉。这确保了复位向量始终位于固件的开头。
- `NOLOAD` 指示链接器这个段在最终的二进制文件中**不占用空间**。它只在RAM中分配空间，但没有需要从ROM加载的初始值
