# 知识类笔记

## 技术类





















## 软件类（Linux）

### ELF文件

ELF 是 Executable and Linking Format 的缩写，它是 Linux 平台上通用的二进制文件格式。主要有以下三种：

- 可重定位文件（Relocatable File），包含由编译器生成的代码以及数据。链接器会将它与其它目标文件链接起来从而创建可执行文件或者共享目标文件。在 Linux 系统中，这种文件的后缀一般为 `.o` 。
- 可执行文件（Executable File），就是我们通常在 Linux 中执行的程序。
- 共享目标文件（Shared Object File），包含代码和数据，这种文件是我们所称的库文件，一般以 `.so` 结尾。

对ELF文件定义的解释

文件格式

- **Executable:** 可执行的。ELF 文件将参与程序的执行（Execution）过程。包括二进制程序的运行以及[动态库](https://so.csdn.net/so/search?q=动态库&spm=1001.2101.3001.7020) .so 文件的加载。
- **Linking:** 可连接的。ELF 文件参与编译链接过程

一般情况下，有两种使用的场景：

- 链接器（Link eDitor, ld）可能会处理它和其它可重定位文件以及共享目标文件，生成另外一个目标文件。
- 动态链接器（Dynamic Linker）将它与可执行文件以及其它共享目标组合在一起生成进程镜像。



### **栈 (Stack)**

定义：栈是内存中一块特殊的、自动管理的区域。它遵循“后进先出”（Last-In, First-Out, LIFO）的原则；

作用：主要用于存储函数的局部变量、函数参数、函数返回地址以及保存函数调用前的寄存器状态。每次调用一个新函数，系统就会在栈上“压入”一个新的数据块（称为栈帧，Stack Frame）；函数返回时，这个栈帧会被“弹出”；

管理：栈的管理是自动的，由编译器生成的代码和CPU指令（如 `PUSH`, `POP`）来完成。你不需要手动 `malloc` 或 `free` 栈上的内存。



### 堆栈 (Heap Stack)

这是一个常见的混淆词。在计算机科学中，**“堆（Heap）”** 和**“栈（Stack）”** 是两个**不同**的内存区域。

**堆 (Heap)** : 是另一块内存区域，用于**动态内存分配**。当你在C语言中使用 `malloc()` 或在 C++ 中使用 `new` 时，你就是在堆上请求内存。堆上的内存必须由程序员手动管理（通过 `free()` 或 `delete` 释放）。

**“堆栈”这个词**: 有时人们会用“堆栈”来泛指“栈”，但在技术上最好将它们分开。你的链接脚本中只定义了栈，没有显式地为堆分配空间（有些C库会把堆放在 `.bss` 段的末尾和栈的开头之间）。



### 栈项

栈有一个特殊的指针寄存器，通常叫做**栈指针（Stack Pointer, SP）** 。

栈顶就是**当前栈操作的位置**，也就是SP寄存器指向的地址。

生长方向：栈有两个生长方向：

- **向下生长（Grows Down）** : 从高地址向低地址生长。这是最常见的模式。调用函数（压栈）时，SP 的值会**减小**。
- **向上生长（Grows Up）** : 从低地址向高地址生长。调用函数时，SP 的值会**增大**



### 关于栈的生长方向

栈的生长方向是由 **CPU 的指令集架构 (Instruction Set Architecture, ISA)** 所决定的。它是一个硬件层面的特性，不是由代码配置的。

**向下生长 (Grows Down)** : 从高地址向低地址生长。这是**绝大多数现代CPU架构**（如 x86, ARM, RISC-V）的标准约定。指的是栈的使用方向。它从**高地址（屋顶）** 开始，向**低地址（地面）** 扩展。每次压栈，栈顶都会移动到更低的地址。

- 当执行一个 `PUSH` 操作或分配栈空间时，栈指针 `SP` 的值会**减小**。
- **栈指针 SP 的值会减小**: 这正是“向下生长”在数值上的体现。`0x8000` -> `0x7FFC` -> `0x7FF8`...
- **最低有效地址（栈底）** : 这指的是栈的**边界**，也就是我们比喻中的“地面” (`__stack_min`)。它是这块区域数值上的最小值，也是栈不能越过的警戒线。

**向上生长 (Grows Up)** : 从低地址向高地址生长。这种方式比较少见，在一些旧的或特殊的架构中存在。

- 执行 `PUSH` 操作时，`SP` 的值会**增大**。



## 硬件类

