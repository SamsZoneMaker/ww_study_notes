swpedia_keyword: [Makefile] 

author:  Sam [desen.li@wisewavetech.com]

------

# Makefile Tutorial



Keywords：





## Makefile 概述



### 为什么要用Makefile？

能够**自动化和优化软件项目的构建过程**，有一定复杂度的项目，手动管理编译、链接和其他相关任务会变得非常繁琐、耗时且容易出错。整个工程的编译只需要一个命令就可以完成编译、 连接以至于最后的执行。

**简化重复劳动**：项目通常包含多个源文件，需要编译成目标文件，然后再链接成可执行文件或库。Makefile 可以将所有这些编译和链接命令组织起来，你只需要执行一个简单的 `make` 命令，它就会自动完成所有必要的步骤。

**固化命令：**手动输入冗长的编译命令很容易出错，Makefile 将这些命令固化下来，确保每次构建都使用相同的、正确的指令。

**增量编译：**Make 工具会检查文件的时间戳。如果某个源文件被修改了，那么只有这个源文件对应的目标文件以及依赖于这个目标文件的其他部分才会被重新编译或链接，这能极大地节省编译时间。

**智能依赖管理**：Makefile 允许你明确定义文件之间的依赖关系（例如，某个目标文件依赖于哪些源文件和头文件）。Make 工具会根据这些依赖关系来决定哪些部分需要更新。

**清晰的项目结构**：Makefile 通过rules来定义如何从源文件生成目标文件，以及最终如何生成可执行文件。项目的构建逻辑更加清晰和且具备一定可读性。

**可执行多种任务：**可以用来定义和执行各种与项目相关的任务。

**跨平台和标准：**make 工具在 类Unix系统（Linux, macOS 等）上是标准配置，在 Windows 上也有相应的版本（如 GNU Make）。不同平台对Makefile的写法有差异，但其基本概念和用法是广泛通用的。



### Makefile编译的内容

Makefile 文件描述了整个工程的编译、连接等规则。其中包括：工程中的哪些源文件需要编译以及如何编译、需要创建那些库文件以及如何创建这些库文件、如何最后产生我们要的可执行文件。



当使用 make 工具进行编译时，工程中以下几种文件在执行 make 时将会被编译（重新编译）：

- 所有的源文件没有被编译过，则对各个 C 源文件进行编译并进行链接，生成最后的可执行 程序；
- 每一个在上次执行 make 之后修改过的 C 源代码文件在本次执行 make 时将会被重新编译；
- 头文件在上一次执行 make 之后被修改。则所有包含此头文件的 C 源文件在本次执行 make 时将会被重新编译。

- 后两种情况是 make 只将修改过的 C 源文件重新编译生成.o 文件，对于没有修改的文件不进 行任何工作。重新编译过程中，任何一个源文件的修改将产生新的对应的.o 文件，新的.o 文件将和 以前的已经存在、此次没有重新编译的.o 文件重新连接生成最后的可执行程序。

规则包含了目标和依赖的关系以及更新目标所要求的命令。



一个Makefile一定包含**目标（Targets）**、**依赖（Prerequisites）**和**命令（Recipes / Commands）**，可能包含 **变量（Variables）**、**伪目标（Phony Targets）**、**规则（Rules）**、**条件判断（Conditional Directives）**、**包含指令（Include Directive）**等等。



### Make如何工作

默认的情况下，make会执行Makefile中的第一个规则，此规则也称之为“最终目标”。当不加任何参数执行Makefile的时候，就会执行该目标中的规则。

在Shell中输入 `make` 指令之后，make会自动读取该目录下的Makefile文件，并自动处理第一个目标里的规则。



对于目标文件的更新，通常有几种情况：

1. 目标文件不存在，则执行规则创建目标；
2. 目标文件已存在，但是依赖的文件有更新，则根据规则重新链接生成
3. 目标文件已存在，依赖文件无更新，无变动



对于 `clean` 的目标在 GUN make文档中定义不能将其作为Makefile的第一个目标，因为Makefile的初衷是创建更新程序，如果只是为了clean，编写一个shell脚本也可以实现同样的功能。



Makefile的命名通常为“makefile”、“Makefile”、“GNUmakefile”（不推荐）。下达`make`指令的时候会自动查找工作目录下的上述三种命名的文件。如果makefile 文件的命名不是这三个任何一个时，需要通过 make 的`-f`或者`--file` 选项来指定 make 读取的 makefile 文件。也可以通过 多个“-f”或者“--file”选项来指定多个需要读取的makefile 文件，多个 makefile 文件将会被 按照指定的顺序进行连接并被 make 解析执行。当通过`-f`或者`--file`指定 make 读取 makefile 的文件时，make 就不再自动查找这三个标准命名的 makefile 文件。



## Makefile的使用



### 包含其他makefile文件

1. include

   Makefile中包含其他文件的关键字是 `include`，使用方法：`include FILENAMES`，这里的 `FILENAMES` 是shell支持的文件名并且也可以使用通配符。

   > [!NOTE]
   >
   > include行不能用[Tab] 开始

2.  变量 `$MAKEFILES`

   可以在当前的环境定义一个环境变量 `$MAKEFILES`，make执行的时候会先读入此变量，变量可以涵盖多个Makefile文件（用空格隔开）。

   但是需要注意：

   - 用该方法引入的Makefile不会被当做make的“最终目标”，如果在工作目录下不存在可被找到的Makefile，则会报错；
   - 环境变量方法的使用即便有错误，make也不会提示，程序也会继续运行；
   - 该方法在make 执行的时候会先被读取，然后才会执行Makefile文件里的内容；而 `include` 的方法是可以随时打断程序运行转到要读取的Makefile。

每个执行的Makefile会被追加到环境变量 `$MAKEFILE_LIST` 中，想知道在执行了哪些Makefile可以打印该变量。



#### 特殊使用场景

因为makefile不允许一个目录下或一次运行中存在相同目标的两个不同规则命令，所以又是

















## 常见问题及补充

1. 一个较长行可以使用反斜线（\）分解为多行，这样做可以使Makefile清晰、容易阅读。

   > [!WARNING]
   >
   > 注反斜线之后不能有空格

2. 命令行的 [Tab]

   命令行必需以[Tab]键开 始，以和Makefile其他行区别。就是说所有的命令行必需以[Tab] 字符开始，但并不是所有的以 [Tab]键出现行都是命令行。但make程序会把出现在第一条规则之后的所有的以[Tab]字符开始的行都作为命令行来处理。

3. 书写规则建议的方式是：单目标，多依赖。就是说尽量要做到一个规则中只存在一个目标文件， 可有多个依赖文件。尽量避免多目标，单依赖的方式。这样后期维护也会非常方便，而且 Makefile 会更清晰、明了。

4. Makefile中可以使用 `-` 放在指令的开头，表示可以忽略该操作的错误，让make可以继续执行



